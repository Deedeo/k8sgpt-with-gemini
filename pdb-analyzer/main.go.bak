package analyzer

import (
    "context"
    "fmt"

    "k8s.io/client-go/kubernetes"
    "k8s.io/client-go/rest"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

    v1 "buf.build/gen/go/k8sgpt-ai/k8sgpt/protocolbuffers/go/schema/v1"
)

// Handler implements the analyzer interface
type Handler struct{}

// NewHandler creates a new analyzer handler
func NewHandler() *Handler {
    return &Handler{}
}

func (a *Handler) Run(ctx context.Context, req *v1.RunRequest) (*v1.RunResponse, error) {
    config, err := rest.InClusterConfig()
    if err != nil {
        return nil, err
    }

    clientset, err := kubernetes.NewForConfig(config)
    if err != nil {
        return nil, err
    }

    missingPDBs := []string{}

    // Get all namespaces
    namespaces, err := clientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
    if err != nil {
        return nil, err
    }

    for _, ns := range namespaces.Items {
        namespace := ns.Name

        // Get deployments
        deployments, err := clientset.AppsV1().Deployments(namespace).List(ctx, metav1.ListOptions{})
        if err != nil {
            continue // skip namespace if error occurs
        }

        // Get statefulsets
        statefulsets, err := clientset.AppsV1().StatefulSets(namespace).List(ctx, metav1.ListOptions{})
        if err != nil {
            continue
        }

        // Get pdbs
        pdbs, err := clientset.PolicyV1().PodDisruptionBudgets(namespace).List(ctx, metav1.ListOptions{})
        if err != nil {
            continue
        }

        // Index PDBs by selector
        pdbMap := make(map[string]struct{})
        for _, pdb := range pdbs.Items {
            selector := pdb.Spec.Selector.String()
            pdbMap[selector] = struct{}{}
        }

        // Check deployments
        for _, deploy := range deployments.Items {
            selector := metav1.FormatLabelSelector(&metav1.LabelSelector{MatchLabels: deploy.Spec.Selector.MatchLabels})
            if _, exists := pdbMap[selector]; !exists {
                missingPDBs = append(missingPDBs, fmt.Sprintf("Deployment '%s/%s'", namespace, deploy.Name))
            }
        }

        // Check statefulsets
        for _, sts := range statefulsets.Items {
            selector := metav1.FormatLabelSelector(&metav1.LabelSelector{MatchLabels: sts.Spec.Selector.MatchLabels})
            if _, exists := pdbMap[selector]; !exists {
                missingPDBs = append(missingPDBs, fmt.Sprintf("StatefulSet '%s/%s'", namespace, sts.Name))
            }
        }
    }

    if len(missingPDBs) == 0 {
        return &v1.RunResponse{
            Result: &v1.Result{
                Name:    "pdb-analyzer",
                Details: "All Deployments and StatefulSets across all namespaces have matching PDBs.",
            },
        }, nil
    }

    return &v1.RunResponse{
        Result: &v1.Result{
            Name:    "pdb-analyzer",
            Details: "Missing PodDisruptionBudgets detected for some workloads.",
            Error: []*v1.ErrorDetail{{
                Text: fmt.Sprintf("Missing PDBs for: %s", missingPDBs),
            }},
        },
    }, nil
}
